<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol Selector</title>
    <style>
        /* Styling for symbol palette */
        #symbolPalette {
            border: 1px solid black;
            width: 200px;
            height: auto;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
        }

        /* Styling for canvas area */
        #canvasArea {
            border: 1px solid black;
            height: 500px;
            margin-top: 20px;
            position: relative;
            background-size: 50px 50px; /* Grid cell size */
            background-image: linear-gradient(to right, rgb(195, 206, 206) 1px, transparent 1px),
                              linear-gradient(to bottom, rgb(195, 206, 206) 1px, transparent 1px);
        }

        /* Styling for draggable symbols */
        .draggable {
            width: 50px;
            cursor: pointer;
            margin: 5px;
        }

        /* Styling for symbols placed on the canvas */
        .symbol {
            position: absolute;
            width: 50px;
            height: 50px;
        }

        /* Styling for line placeholder */
        .line-placeholder {
            background-color: #5a5959;
            position: absolute;
            height: 1px;
            z-index: 0;
        }

        /* Styling for control panel and buttons */
        #controlPanel {
            margin-top: 20px;
        }

        .button {
            padding: 10px 20px;
            margin-right: 10px;
        }
    </style>
</head>
<body>

<div id="symbolPalette">
    <img src="https://drive.google.com/uc?export=view&id=190ff8p-6cfom1nshE3yk4vlnDr1XrHGZ" class="draggable" unitId="factory_grid" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1uXCylCbVPnFXkK13kicBW4kEXos7X863" class="draggable" unitId="home_grid" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1GOb73e-MAgzj8lTqYC3rLU4g7WWlvlLl" class="draggable" unitId="solar_Inverter_5kW" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1bGL5ie8svwp-F_d5TRAmCvXeA6-XxoN4" class="draggable" unitId="monitoring" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1-ABgfWbbN1fJy6oN8rSlzd0naB7xzhCx" class="draggable" unitId="solar_Panel_550W" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1sh9Erta4xI-IbLwJ-wSjynNnfsjmvi-d" class="draggable" unitId="DC_Disconnect_20A" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1O4R-58orMtTye8dZLWkgrqQx-Rbeo6OZ" class="draggable" unitId="AC_MCB_30A" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1Ie2JXc_DJp4fncAY_lQnjbFUEFdMQQpr" class="draggable" unitId="surge_arrestor_DC_20A" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1YXKchizyliUMlucvUPYpN2tDYj3Kc9I8" class="draggable" unitId="surge_arrestor_AC_100A" draggable="true">
    <img src="https://drive.google.com/uc?export=view&id=1wC7GPkUtoCDxlvevwVCsfU2S1YrBTH9E" class="draggable" unitId="off_grid_inverter" draggable="true">
    <!-- Add more draggable symbols as needed -->
</div>

<div id="canvasArea">
    <!-- Users will drop symbols or lines here -->
</div>

<div id="controlPanel">
    <input type="file" id="openButton" class="button">
    <button id="saveButton" class="button">Save</button>
    <button id="undoButton" class="button">Undo</button>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvasArea = document.getElementById('canvasArea');
        let lineStartSymbol = null;
        let symbolCounter = 0;
        let lineCounter = 0;
        let symbols = [];
        let lines = [];
        let nextSymbolRef = 1; // Initialize a variable to keep track of the next symbol reference
    
        document.querySelectorAll('.draggable').forEach(item => {
            item.addEventListener('dragstart', e => {
                e.dataTransfer.setData("text/plain", e.target.src);
            });
        });
    
        canvasArea.addEventListener('dragover', e => {
            e.preventDefault();
        });
    
        canvasArea.addEventListener('drop', e => {
            e.preventDefault();
            const src = e.dataTransfer.getData("text/plain");
            createSymbol(src, e.offsetX - 25, e.offsetY - 25);
        });
    

        function createSymbol(src, x, y, unitId) {
            const img = document.createElement('img');

            // Snap x and y to the nearest grid point
            const gridSize = 50; // Define grid size (50x50 pixels)
            x = snapToGrid(x, gridSize);
            y = snapToGrid(y, gridSize);

            // Set the left and top styles with the snapped coordinates
            img.style.left = x + 'px';
            img.style.top = y + 'px';

            img.src = src;
            img.classList.add('symbol', 'draggable');
            img.style.left = x + 'px';
            img.style.top = y + 'px';

            // Use the provided unitId as the unitId attribute
            img.setAttribute('unitId', unitId);  // Set the unitId attribute

            img.dataset.symbolRef = `symbol${nextSymbolRef++}`;

            img.addEventListener('dblclick', () => {
                if (!lineStartSymbol) {
                    lineStartSymbol = img;
                } else {
                    drawLine(lineStartSymbol, img);
                    lineStartSymbol = null;
                }
            });

            canvasArea.appendChild(img);
            symbols.push(img);
            return img;
        }
    
        function snapToGrid(value, gridSize) {
            // Round the value to the nearest multiple of gridSize
            return Math.round(value / gridSize) * gridSize;
        }
    
        function drawLine(symbol1, symbol2) {
            const x1 = parseInt(symbol1.style.left, 10) + 25;
            const y1 = parseInt(symbol1.style.top, 10) + 25;
            const x2 = parseInt(symbol2.style.left, 10) + 25;
            const y2 = parseInt(symbol2.style.top, 10) + 25;
    
            const line = document.createElement('div');
            line.className = 'line-placeholder';
            line.dataset.id = `line${++lineCounter}`;
            line.dataset.from = symbol1.dataset.symbolRef; // Use symbolRef instead of id
            line.dataset.to = symbol2.dataset.symbolRef;     // Use symbolRef instead of id
    
            const length = Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
    
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.transformOrigin = '0 0';
    
            canvasArea.appendChild(line);
            lines.push(line);
        }
    
        document.getElementById('saveButton').addEventListener('click', () => {
            const savedData = {
                symbols: [],
                lines: lines.map(line => ({
                    id: line.dataset.id,
                    fromSymbolRef: line.dataset.from,
                    toSymbolRef: line.dataset.to
                }))
            };

            // Create a set to keep track of unique symbol references
            const uniqueSymbolRefs = new Set();

            // Iterate through symbols and add them to the savedData if they are unique
            symbols.forEach(s => {
                const symbolRef = s.dataset.symbolRef; // Use symbolRef instead of id
                const unitId = s.getAttribute('unitId');                // Get the unitId attribute
                const symbolSrc = s.src;
                const symbolX = s.style.left;
                const symbolY = s.style.top;

                // Generate a unique identifier based on symbolRef, x, and y coordinates
                const uniqueIdentifier = `${symbolRef}_${symbolX}_${symbolY}`;

                // Check if this identifier is unique
                if (!uniqueSymbolRefs.has(uniqueIdentifier)) {
                    savedData.symbols.push({
                        unitId: unitId,          // Use unitId instead of id
                        symbolRef: symbolRef, // Use symbolRef instead of id
                        src: symbolSrc,
                        x: symbolX,
                        y: symbolY
                    });

                    // Add the identifier to the set of unique identifiers
                    uniqueSymbolRefs.add(uniqueIdentifier);
                }
            });

            const blob = new Blob([JSON.stringify(savedData)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', 'canvasState.json');
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    
        document.getElementById('openButton').addEventListener('change', function() {
            const fileReader = new FileReader();
            fileReader.onload = function(event) {
                const data = JSON.parse(event.target.result);

                canvasArea.innerHTML = '';
                symbolCounter = 0;
                lineCounter = 0;
                symbols = [];
                lines = [];

                data.symbols.forEach(sym => {
                    const img = createSymbol(sym.src, parseInt(sym.x, 10), parseInt(sym.y, 10), sym.unitId);
                    symbols.push(img);
                });

                data.lines.forEach(line => {
                    const fromSymbol = symbols.find(s => s.dataset.symbolRef === line.fromSymbolRef);
                    const toSymbol = symbols.find(s => s.dataset.symbolRef === line.toSymbolRef);
                    if (fromSymbol && toSymbol) {
                        drawLine(fromSymbol, toSymbol);
                    }
                });
            };
            if (this.files && this.files[0]) {
                fileReader.readAsText(this.files[0]);
            }
        });
    
        document.getElementById('undoButton').addEventListener('click', () => {
            if (lines.length > 0) {
                const lastLine = lines.pop();
                canvasArea.removeChild(lastLine);
            } else if (symbols.length > 0) {
                const lastSymbol = symbols.pop();
                canvasArea.removeChild(lastSymbol);
            }
        });
    });
</script>

</body>
</html>